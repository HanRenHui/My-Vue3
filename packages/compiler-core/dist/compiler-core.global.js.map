{
  "version": 3,
  "sources": ["../src/index.ts", "../src/runtimeHelpers.ts", "../src/ast.ts", "../src/parse.ts", "../transforms/transformElement.ts", "../transforms/transformExpression.ts", "../transforms/transformText.ts", "../src/transform.ts"],
  "sourcesContent": ["import { parse } from './parse'\nimport { transform } from './transform'\n\nexport function compile(template) {\n  const templateAST = parse(template)\n\n  console.log('ast', templateAST)\n\n  const jsAST = transform(templateAST)\n\n  console.log('jsAst', jsAST)\n}\n", "export const TO_DISPLAY_STRING = Symbol.for('toDisplayString')\nexport const CREATE_TEXT = Symbol.for('createTextVnode')\nexport const CREATE_ELEMENT_VNODE = Symbol.for('createElementVNode')\nexport const CREATE_BLOCK_VNODE = Symbol.for('createBlockVNode')\nexport const OPEN_BLOCK = Symbol.for('openBlock')\nexport const FRAGEMENT = Symbol.for('fragment')\nexport const helperMap = {\n  [TO_DISPLAY_STRING]: 'toDisplayString',\n  [CREATE_TEXT]: 'createTextVnode',\n  [CREATE_ELEMENT_VNODE]: 'createElementVNode',\n  [CREATE_BLOCK_VNODE]: 'createBlockVNode',\n  [OPEN_BLOCK]: 'openBlock',\n  [FRAGEMENT]: 'fragement'\n}\n", "import { CREATE_ELEMENT_VNODE, CREATE_TEXT } from './runtimeHelpers'\n\nexport const enum NodeTypes {\n  ROOT, // \u6839\u8282\u70B9\n  ELEMENT, // \u5143\u7D20\n  TEXT, // \u6587\u672C\n  COMMENT, // \u6CE8\u91CA\n  SIMPLE_EXPRESSION, // \u7B80\u5355\u8868\u8FBE\u5F0F  aaa   :a=\"aa\"\n  INTERPOLATION, // \u6A21\u677F\u8868\u8FBE\u5F0F  {{aaa}}\n  ATTRIBUTE,\n  DIRECTIVE,\n  // containers\n  COMPOUND_EXPRESSION, // \u590D\u5408\u8868\u8FBE\u5F0F  {{aa}} abc\n  IF,\n  IF_BRANCH,\n  FOR,\n  TEXT_CALL, // \u6587\u672C\u8C03\u7528 \u9700\u8981\u5355\u72EC\u7ED9\u6587\u672C\u8C03\u7528createTextContent \u5982\u679C\u662FTEXT\u7684\u8BDD \u76F4\u63A5\u63A5innerText\u5C31\u597D\u4E86\n  // codegen\n  VNODE_CALL, // \u5143\u7D20\u8C03\u7528\n  JS_CALL_EXPRESSION, // js\u8C03\u7528\u8868\u8FBE\u5F0F\n  JS_OBJECT_EXPRESSION\n}\n\n// type\u53EF\u4EE5\u662FNodeTypes.TEXT  NodeTypes.INTERPOLATION COMPOUND_EXPRESSION\n// \u5047\u5982\u9700\u8981\u8C03\u7528createTextVNode(\u6587\u672C\u8282\u70B9\u6709\u5144\u5F1F\u8282\u70B9)\u7684\u8BDD \u4F1A\u53D8\u6210 NodeTypes.TEXT_CALL\n\n// \u5404\u79CDast\u7684\u6570\u636E\u683C\u5F0F\n// root\n// {\n//     type: NodeTypes.ROOT,\n//     loc,\n//     children\n// }\n\n// Element\n//     type: NodeTypes.ELEMENT,\n//     isSelfClosing,\n//     tag,\n//     props: ATTREBUTE[], // attribute\u8282\u70B9\u7684\u6570\u7EC4\n//     children: [],\n//     loc: getSelection(context, start)\n\n// ATTRIBUTE \u5C5E\u6027\n// loc: getSelection(context, start),\n// name,\n// value: attributeValue\u8282\u70B9,\n// type: NodeTypes.ATTRIBUTE\n\n// attributeValue\n// content,\n// loc: getSelection(context, start),\n// type: NodeTypes.TEXT\n\n// \u8868\u8FBE\u5F0F\n// return {\n//     type: NodeTypes.INTERPOLATION,\n//     content: {\n//       type: NodeTypes.SIMPLE_EXPRESSION,\n//       content,\n//       loc: getSelection(context, innerStart, innerEnd)\n//     },\n//     loc: getSelection(context, outerStart)\n//   }\n\n// \u7EAF\u6587\u672C\n// type: NodeTypes.TEXT,\n// loc: getSelection(context, start),\n// content\n\n// \u9700\u8981\u8C03\u7528createTextNode\u521B\u5EFA\u7684\u6587\u672C\u8282\u70B9\n// type: NodeTypes.TEXT_CALL\n// context: Text\u7684node\u8282\u70B9\u7684\u5185\u5BB9\n\nexport function createCallExpression(context, args) {\n  const callee = context.helper(CREATE_TEXT)\n  return {\n    callee,\n    arguments: args,\n    type: NodeTypes.JS_CALL_EXPRESSION\n  }\n}\nexport function createObjectExpression(propirties) {\n  return {\n    type: NodeTypes.JS_OBJECT_EXPRESSION,\n    propirties\n  }\n}\nexport function createVnodeCall(context, tag, propirties, children) {\n  context.helper(CREATE_ELEMENT_VNODE)\n  return {\n    type: NodeTypes.VNODE_CALL,\n    tag,\n    propirties,\n    children\n  }\n}\n", "import { NodeTypes } from './ast'\n// there still has some problems\n\nfunction advancePositionWithMutation(context, source, endIndex) {\n  // line column offset\n  let linsCount = 0 // \u56DE\u8F66\u6570\n  let linePos = -1\n  for (let i = 0; i < endIndex; i++) {\n    if (source.charCodeAt(i) == 10) {\n      // \u6362\u884C\u6216\u8005\u56DE\u8F66\n      linsCount++\n      linePos = i\n    }\n  }\n\n  context.line += linsCount\n  if (linePos === -1) {\n    context.column += endIndex\n  } else {\n    context.column = endIndex - linePos\n  }\n\n  context.offset += endIndex\n}\n\nfunction advanceBy(context, endIndex) {\n  advancePositionWithMutation(context, context.source, endIndex)\n\n  context.source = context.source.slice(endIndex)\n}\n\nfunction parseTextData(context, endIndex) {\n  const rawText = context.source.slice(0, endIndex)\n  advanceBy(context, endIndex)\n  return rawText\n}\n\nfunction getCursor(context) {\n  const { line, column, offset } = context\n  return {\n    line,\n    column,\n    offset\n  }\n}\n\nfunction getSelection(context, start, end?) {\n  end = end || getCursor(context)\n  return {\n    start,\n    end,\n    source: context.originSource.slice(start.offset, end.offset)\n  }\n}\n\nfunction parseText(context) {\n  const endTokens = ['{{', '<']\n  let lastIndex = context.source.length\n  for (let i = 0; i < endTokens.length; i++) {\n    const index = context.source.indexOf(endTokens[i])\n    if (index !== -1 && lastIndex > index) {\n      lastIndex = index\n    }\n  }\n\n  const start = getCursor(context)\n\n  const content = parseTextData(context, lastIndex)\n\n  return {\n    type: NodeTypes.TEXT,\n    loc: getSelection(context, start),\n    content\n  }\n}\n\nfunction parseInterception(context) {\n  const outerStart = getCursor(context)\n  const closeIndex = context.source.indexOf('}}')\n\n  advanceBy(context, 2)\n\n  const innerStart = getCursor(context)\n  const innerEnd = getCursor(context)\n\n  const originContent = parseTextData(context, closeIndex - 2)\n  const content = originContent.trim()\n\n  const startOffset = originContent.indexOf(content)\n  if (startOffset) {\n    advancePositionWithMutation(innerStart, originContent, startOffset)\n  }\n\n  const endOffset = startOffset + content.length\n\n  advancePositionWithMutation(innerEnd, originContent, endOffset)\n\n  advanceBy(context, 2)\n\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: {\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      content,\n      loc: getSelection(context, innerStart, innerEnd)\n    },\n    loc: getSelection(context, outerStart)\n  }\n}\nfunction advanceBySpaces(context) {\n  const reg = /^[ \\r\\n\\t]*/\n  const match = reg.exec(context.source)\n  if (match) {\n    advanceBy(context, match[0].length)\n  }\n}\n\nfunction parseAttributeValue(context) {\n  const start = getCursor(context)\n\n  const quote = context.source[0]\n\n  let content = ''\n  if (quote === '\"' || quote === \"'\") {\n    advanceBy(context, 1)\n    const closeIndex = context.source.indexOf(quote)\n    content = parseTextData(context, closeIndex)\n    advanceBy(context, 1)\n  }\n  return {\n    content,\n    loc: getSelection(context, start),\n    type: NodeTypes.TEXT\n  }\n}\n\nfunction parseAttribute(context) {\n  const start = getCursor(context)\n  const match = /^[^\\r\\n\\t\\f=]+/.exec(context.source)\n  const name = match[0]\n  advanceBy(context, name.length)\n  advanceBySpaces(context)\n  advanceBy(context, 1)\n  advanceBySpaces(context)\n  const value = parseAttributeValue(context)\n  return {\n    loc: getSelection(context, start),\n    name,\n    value,\n    type: NodeTypes.ATTRIBUTE\n  }\n}\nfunction parseAttributes(context) {\n  const props = []\n  while (context.source && !context.source.startsWith('>')) {\n    // a = \"123\"\n    const prop = parseAttribute(context)\n    props.push(prop)\n    advanceBySpaces(context)\n  }\n\n  return props\n}\n\nfunction parseTag(context) {\n  const start = getCursor(context)\n  // const reg = /^<\\/?[a-z][^\\t\\r\\n]*/\n  const reg = /^<\\/?([a-z][^ \\t\\r\\n/>]*)/\n  const match = reg.exec(context.source)\n  const tag = match[1]\n  advanceBy(context, match[0].length)\n  advanceBySpaces(context)\n  // const tag = match[0]\n  const isSelfClosing = context.source.startsWith('</')\n  const props = parseAttributes(context)\n\n  advanceBy(context, isSelfClosing ? 2 : 1)\n\n  return {\n    type: NodeTypes.ELEMENT,\n    isSelfClosing,\n    tag,\n    props,\n    children: [],\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseElement(context) {\n  const ele = parseTag(context)\n  const nodes = parseChildren(context)\n  if (context.source.startsWith('</')) {\n    parseTag(context)\n  }\n  ele.children = nodes\n  return ele\n}\n\nfunction parseChildren(context: Record<string, any>) {\n  const nodes = []\n  let node = null\n  while (context.source && !context.source.startsWith('</')) {\n    if (context.source.startsWith('<')) {\n      // \u6807\u7B7E\n      node = parseElement(context)\n      // break\n    } else if (context.source.startsWith('{{')) {\n      // \u63D2\u503C\n      node = parseInterception(context)\n    } else {\n      // \u6587\u672C\n      node = parseText(context)\n    }\n    nodes.push(node)\n  }\n  // \u53BB\u9664\u7A7A\u767D\u5B57\u7B26\u7684node\u8282\u70B9\n  nodes.forEach((node, i) => {\n    if (node.type === NodeTypes.TEXT && /^[\\r\\n\\t\\f ]*$/.exec(node.content)) {\n      nodes[i] = null\n    }\n  })\n  return nodes.filter(Boolean)\n}\n\nfunction createContext(source: string) {\n  return {\n    originSource: source,\n    source,\n    line: 1,\n    column: 1,\n    offset: 0\n  }\n}\n\nfunction createRootNode(children, loc) {\n  return {\n    type: NodeTypes.ROOT,\n    loc,\n    children\n  }\n}\n\nexport function parse(template: string) {\n  const context = createContext(template)\n  const start = getCursor(context)\n  const nodes = parseChildren(context)\n  const RootNode = createRootNode(nodes, getSelection(context, start))\n  return RootNode\n}\n", "import { createObjectExpression, createVnodeCall, NodeTypes } from '../src/ast'\n\nexport function transformElement(node, context) {\n  if (node.type === NodeTypes.ELEMENT) {\n    return () => {\n      // console.log('out element', node.tag)\n      const props = node.props || {}\n      const propirties = []\n      for (const key in props) {\n        const value = props[key]\n        propirties.push({\n          key,\n          value: value.content\n        })\n      }\n\n      const propertyExpression = propirties.length ? createObjectExpression(propirties) : null\n\n      let childrenNodes = null\n      if (node.children.length === 1) {\n        childrenNodes = node.children[0]\n      } else {\n        childrenNodes = node.children\n      }\n\n      node.codegenNode = createVnodeCall(context, node.tag, propertyExpression, childrenNodes)\n    }\n  }\n}\n", "import { NodeTypes } from '../src/ast'\n\nexport function transformExpression(node, context) {\n  if (node.type === NodeTypes.INTERPOLATION) {\n    const content = node.content.content\n    node.content.content = `_ctx.${content}`\n  }\n}\n", "import { PatchFlags } from '@vue3/shared'\nimport { createCallExpression, NodeTypes } from '../src/ast'\nfunction isText(node) {\n  return node.type === NodeTypes.TEXT || node.type === NodeTypes.INTERPOLATION\n}\nexport function transformText(node, context) {\n  if (node.type === NodeTypes.ROOT || node.type === NodeTypes.ELEMENT) {\n    // do something\n    return () => {\n      // \u5408\u5E76\u666E\u901A\u6587\u672C\u5B50\u8282\u70B9\u548C\u8868\u8FBE\u5F0F\u8282\u70B9\n      const children = node.children\n      // \u6807\u8BB0\u662F\u5426\u6709\u6587\u672C\u5B50\u8282\u70B9\n      let hasText = false\n      for (let i = 0; i < children.length; i++) {\n        const curChildren = children[i]\n        let currentContainer = null\n        if (isText(curChildren)) {\n          hasText = true\n          // \u67E5\u627E\u8FDE\u7EED\u5B50\u8282\u70B9\n          for (let j = i + 1; j < children.length; j++) {\n            const nextChildren = children[j]\n            if (isText(nextChildren)) {\n              if (!currentContainer) {\n                currentContainer = children[i] = {\n                  type: NodeTypes.COMPOUND_EXPRESSION,\n                  children: [curChildren]\n                }\n              }\n              currentContainer.children.push(`+`, nextChildren)\n              children.splice(j, 1)\n              j--\n            } else {\n              currentContainer = null\n              break\n            }\n          }\n        }\n      }\n\n      // \u4E3Aast\u8282\u70B9\u6DFB\u52A0codegennode generate\u9636\u6BB5\u9700\u8981handlerCloudStorage\n\n      if (!hasText || children.length === 1) {\n        return\n      }\n\n      for (let i = 0; i < children.length; i++) {\n        const curChild = children[i]\n        const args = [curChild]\n        if (isText(curChild) || curChild.type === NodeTypes.COMPOUND_EXPRESSION) {\n          if (curChild.type !== NodeTypes.TEXT) {\n            // \u8BF4\u660E\u662F\u52A8\u6001\u8282\u70B9 \u9700\u8981 \u4F20\u5165patchFlags \u505A\u9776\u5411\u66F4\u65B0\n            args.push(PatchFlags.TEXT)\n          }\n          children[i] = {\n            type: NodeTypes.TEXT_CALL, // \u9700\u8981\u8C03\u7528createTextNode\n            content: curChild,\n            codegenNode: createCallExpression(context, args)\n          }\n        }\n      }\n    }\n  }\n}\n", "import { transformElement } from '../transforms/transformElement'\nimport { transformExpression } from '../transforms/transformExpression'\nimport { transformText } from '../transforms/transformText'\nimport { createVnodeCall, NodeTypes } from './ast'\nimport { CREATE_BLOCK_VNODE, CREATE_ELEMENT_VNODE, FRAGEMENT, OPEN_BLOCK, TO_DISPLAY_STRING } from './runtimeHelpers'\n\nfunction createTransformContext() {\n  const context = {\n    parent: null,\n    currentNode: null,\n    helpers: new Map(),\n    helper(name) {\n      const count = context.helpers.get(name) || 0\n      context.helpers.set(name, count + 1)\n      return name\n    },\n    removeHelper(name) {\n      let count = context.helpers.get(name)\n      count--\n      if (count) {\n        context.helpers.set(name, count)\n      } else {\n        context.helpers.delete(count)\n      }\n    },\n    nodeTransforms: [transformElement, transformText, transformExpression]\n  }\n\n  return context\n}\n\nfunction traverse(ast, context) {\n  const currentNode = (context.currentNode = ast)\n  const transforms = context.nodeTransforms\n  const exitFns = []\n  for (let i = 0; i < transforms.length; i++) {\n    const exitFn = transforms[i](ast, context)\n    if (typeof exitFn === 'function') {\n      exitFns.push(exitFn)\n    }\n  }\n\n  switch (currentNode.type) {\n    case NodeTypes.INTERPOLATION:\n      context.helper(TO_DISPLAY_STRING)\n      break\n    case NodeTypes.ELEMENT:\n    case NodeTypes.ROOT:\n      const children = currentNode.children\n      for (let i = 0; i < children.length; i++) {\n        traverse(children[i], context)\n      }\n  }\n\n  context.currentNode = ast\n  let i = 0\n  while (i < exitFns.length) {\n    exitFns[i]()\n    i++\n  }\n}\n\nfunction createRootCodegen(ast, context) {\n  const children = ast.children\n  if (children.length === 1) {\n    const child = children[0]\n    if (child.type === NodeTypes.ELEMENT && child.codegenNode) {\n      ast.codegenNode = child.codegenNode\n      ast.codegenNode.isBlock = true\n      context.removeHelper(CREATE_ELEMENT_VNODE)\n      context.helper(OPEN_BLOCK)\n      context.helper(CREATE_BLOCK_VNODE)\n    } else {\n      ast.codegenNode = child.codegenNode\n    }\n  } else {\n    if (!children.length) return null\n    context.helper(FRAGEMENT)\n    ast.codegenVnode = createVnodeCall(context, FRAGEMENT, null, ast.children)\n  }\n}\nexport function transform(ast) {\n  const context = createTransformContext()\n  traverse(ast, context)\n  createRootCodegen(ast, context)\n  ast.helpers = [...context.helpers.keys()]\n}\n"],
  "mappings": "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",
  "names": []
}
