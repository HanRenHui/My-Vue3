{
  "version": 3,
  "sources": ["../src/index.ts", "../src/parse.ts"],
  "sourcesContent": ["import { parse } from './parse'\nimport { transform } from './transform'\n\nexport function compile(template) {\n  const templateAST = parse(template)\n\n  console.log('ast', templateAST)\n\n  // const jsAST = transform(templateAST)\n\n  // console.log('jsAst', jsAST)\n}\n", "import { NodeTypes } from './ast'\n// there still has some problems\n\nfunction advancePositionWithMutation(context, source, endIndex) {\n  // line column offset\n  let linsCount = 0 // \u56DE\u8F66\u6570\n  let linePos = -1\n  for (let i = 0; i < endIndex; i++) {\n    if (source.charCodeAt(i) == 10) {\n      // \u6362\u884C\u6216\u8005\u56DE\u8F66\n      linsCount++\n      linePos = i\n    }\n  }\n\n  context.line += linsCount\n  if (linePos === -1) {\n    context.column += endIndex\n  } else {\n    context.column = endIndex - linePos\n  }\n\n  context.offset += endIndex\n}\n\nfunction advanceBy(context, endIndex) {\n  advancePositionWithMutation(context, context.source, endIndex)\n\n  context.source = context.source.slice(endIndex)\n}\n\nfunction parseTextData(context, endIndex) {\n  const rawText = context.source.slice(0, endIndex)\n  advanceBy(context, endIndex)\n  return rawText\n}\n\nfunction getCursor(context) {\n  const { line, column, offset } = context\n  return {\n    line,\n    column,\n    offset\n  }\n}\n\nfunction getSelection(context, start, end?) {\n  end = end || getCursor(context)\n  return {\n    start,\n    end,\n    source: context.originSource.slice(start.offset, end.offset)\n  }\n}\n\nfunction parseText(context) {\n  const endTokens = ['{{', '<']\n  let lastIndex = context.source.length\n  for (let i = 0; i < endTokens.length; i++) {\n    const index = context.source.indexOf(endTokens[i])\n    if (index !== -1 && lastIndex > index) {\n      lastIndex = index\n    }\n  }\n\n  const start = getCursor(context)\n\n  const content = parseTextData(context, lastIndex)\n\n  return {\n    type: NodeTypes.TEXT,\n    loc: getSelection(context, start),\n    content\n  }\n}\n\nfunction parseInterception(context) {\n  const outerStart = getCursor(context)\n  const closeIndex = context.source.indexOf('}}')\n\n  advanceBy(context, 2)\n\n  const innerStart = getCursor(context)\n  const innerEnd = getCursor(context)\n\n  const originContent = parseTextData(context, closeIndex - 2)\n  const content = originContent.trim()\n\n  const startOffset = originContent.indexOf(content)\n  if (startOffset) {\n    advancePositionWithMutation(innerStart, originContent, startOffset)\n  }\n\n  const endOffset = startOffset + content.length\n\n  advancePositionWithMutation(innerEnd, originContent, endOffset)\n\n  advanceBy(context, 2)\n\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: {\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      content,\n      loc: getSelection(context, innerStart, innerEnd)\n    },\n    loc: getSelection(context, outerStart)\n  }\n}\nfunction advanceBySpaces(context) {\n  const reg = /^[ \\r\\n\\t]*/\n  const match = reg.exec(context.source)\n  if (match) {\n    advanceBy(context, match[0].length)\n  }\n}\n\nfunction parseAttributeValue(context) {\n  const start = getCursor(context)\n\n  const quote = context.source[0]\n\n  let content = ''\n  if (quote === '\"' || quote === \"'\") {\n    advanceBy(context, 1)\n    const closeIndex = context.source.indexOf(quote)\n    content = parseTextData(context, closeIndex)\n    advanceBy(context, 1)\n  }\n  return {\n    content,\n    loc: getSelection(context, start),\n    type: NodeTypes.TEXT\n  }\n}\n\nfunction parseAttribute(context) {\n  const start = getCursor(context)\n  const match = /^[^\\r\\n\\t\\f=]+/.exec(context.source)\n  const name = match[0]\n  advanceBy(context, name.length)\n  advanceBySpaces(context)\n  advanceBy(context, 1)\n  advanceBySpaces(context)\n  const value = parseAttributeValue(context)\n  return {\n    loc: getSelection(context, start),\n    name,\n    value,\n    type: NodeTypes.ATTRIBUTE\n  }\n}\nfunction parseAttributes(context) {\n  const props = []\n  while (context.source && !context.source.startsWith('>')) {\n    // a = \"123\"\n    const prop = parseAttribute(context)\n    props.push(prop)\n    advanceBySpaces(context)\n  }\n\n  return props\n}\n\nfunction parseTag(context) {\n  const start = getCursor(context)\n  // const reg = /^<\\/?[a-z][^\\t\\r\\n]*/\n  const reg = /^<\\/?([a-z][^ \\t\\r\\n/>]*)/\n  const match = reg.exec(context.source)\n  const tag = match[1]\n  advanceBy(context, match[0].length)\n  advanceBySpaces(context)\n  // const tag = match[0]\n  const isSelfClosing = context.source.startsWith('</')\n  const props = parseAttributes(context)\n\n  advanceBy(context, isSelfClosing ? 2 : 1)\n\n  return {\n    type: NodeTypes.ELEMENT,\n    isSelfClosing,\n    tag,\n    props,\n    children: [],\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseElement(context) {\n  const ele = parseTag(context)\n  const nodes = parseChildren(context)\n  if (context.source.startsWith('</')) {\n    parseTag(context)\n  }\n  ele.children = nodes\n  return ele\n}\n\nfunction parseChildren(context: Record<string, any>) {\n  const nodes = []\n  let node = null\n  while (context.source && !context.source.startsWith('</')) {\n    if (context.source.startsWith('<')) {\n      // \u6807\u7B7E\n      node = parseElement(context)\n      // break\n    } else if (context.source.startsWith('{{')) {\n      // \u63D2\u503C\n      node = parseInterception(context)\n    } else {\n      // \u6587\u672C\n      node = parseText(context)\n    }\n    nodes.push(node)\n  }\n  // \u53BB\u9664\u7A7A\u767D\u5B57\u7B26\u7684node\u8282\u70B9\n  nodes.forEach((node, i) => {\n    if (node.type === NodeTypes.TEXT && /^[\\r\\n\\t\\f ]*$/.exec(node.content)) {\n      nodes[i] = null\n    }\n  })\n  return nodes.filter(Boolean)\n}\n\nfunction createContext(source: string) {\n  return {\n    originSource: source,\n    source,\n    line: 1,\n    column: 1,\n    offset: 0\n  }\n}\n\nfunction createRootNode(children, loc) {\n  return {\n    type: NodeTypes.ROOT,\n    loc,\n    children\n  }\n}\n\nexport function parse(template: string) {\n  const context = createContext(template)\n  const start = getCursor(context)\n  const nodes = parseChildren(context)\n  const RootNode = createRootNode(nodes, getSelection(context, start))\n  return RootNode\n}\n"],
  "mappings": "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",
  "names": []
}
